package v1

import (
	"encoding/json"
	"fmt"
	"github.com/eolso/memcache"
	"github.com/go-chi/chi"
	"io/ioutil"
	"net/http"
	"time"
)

const (
	roomMetadataKey = "metadata"
	roomUsersKey    = "users"
	roomMessagesKey = "messages"
	roomInvitesKey  = "invites"
)

type CreateRoomBody struct {
	Name string `json:"name"`
}

type InviteUserBody struct {
	ID string `json:"id"`
}

type SendMessageBody struct {
	Message string `json:"message"`
}

type PatchRoomUserBody struct {
	DisplayName string `json:"display_name"`
}

// CreateRoomHandler creates a room.
func CreateRoomHandler(roomsCollection *memcache.Collection) func(w http.ResponseWriter, r *http.Request) {
	// TODO do some permission checking against an API key
	return func(w http.ResponseWriter, r *http.Request) {
		// Get the authed user generated by the ApiAuthMiddleware
		userID, ok := r.Context().Value("userID").(string)
		if !ok {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		b, err := ioutil.ReadAll(r.Body)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		var crb CreateRoomBody
		if err = json.Unmarshal(b, &crb); err != nil {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		// Room IDs are generally unique so we won't check for existence.
		// Collision is possible if > 16,777,216 rooms are created in a second.
		// TODO perhaps set a limit to the amount of rooms a single user can create/join
		room := NewRoom(crb.Name).WithOwner(userID)

		// Create the room collection
		thisRoomCollection := roomsCollection.Collection(room.UID())

		// Insert the room metadata into the collection
		// TODO maybe flatten this before inserting the data? Would just need to figure out how to best unflatten it later.
		thisRoomCollection.Document(roomMetadataKey).SetMap(memcache.FlattenStruct(room))
		//thisRoomCollection.Document(roomMetadataKey).Set("metadata", room)

		// Insert the user list into the room's collection. This is just the creator's identity.
		thisRoomCollection.Document(roomUsersKey).Set(userID, userID)

		// Insert the message list into the room's document.
		message := NewMessage(fmt.Sprintf("%s has joined the room. Say hi!", userID), Identity{"system", "system"})
		thisRoomCollection.Document(roomMessagesKey).Set(message.ID, message)

		// Insert an empty invites list into the room's document.
		thisRoomCollection.Document(roomInvitesKey)

		// Return the room's metadata to the caller
		b, err = json.Marshal(room)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
		w.Write(b)
	}
}

// GetRoomHandler gets a room if it is available to the user.
func GetRoomHandler(roomsCollection *memcache.Collection) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		roomID := chi.URLParam(r, "roomID")
		if roomID == "" {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		// Get the authed user generated by the ApiAuthMiddleware
		userID, ok := r.Context().Value("userID").(string)
		if !ok {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		thisRoomCollection, ok := roomsCollection.GetCollection(roomID)
		if !ok {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		// Verify that the authed user exists in the room
		if _, ok = thisRoomCollection.Document(roomUsersKey).Get(userID); !ok {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		// TODO maybe allow for invited users to automatically join when hitting this endpoint too

		// Return the room's metadata
		// TODO this shit is just flat out wrong lol. Should probably unflatten it or something.
		room := thisRoomCollection.Document(roomMetadataKey).Map

		b, err := json.Marshal(room)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
		w.Write(b)
	}
}

// DeleteRoomHandler deletes a room.
func DeleteRoomHandler(roomsCollection *memcache.Collection) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		roomID := chi.URLParam(r, "roomID")
		if roomID == "" {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		// Get the authed user generated by the ApiAuthMiddleware
		userID, ok := r.Context().Value("userID").(string)
		if !ok {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		thisRoomCollection, ok := roomsCollection.GetCollection(roomID)
		if !ok {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		// Only the owner can delete a room.
		owner, _ := thisRoomCollection.Document(roomMetadataKey).Get("OwnerID")
		ownerID, ok := owner.(string)
		if !ok || ownerID != userID {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		roomsCollection.DeleteCollection(roomID)

		w.WriteHeader(http.StatusOK)
	}
}

func JoinRoomHandler(roomsCollection *memcache.Collection) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		roomID := chi.URLParam(r, "roomID")
		if roomID == "" {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		// Get the authed user generated by the ApiAuthMiddleware
		userID, ok := r.Context().Value("userID").(string)
		if !ok {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		thisRoomCollection, ok := roomsCollection.GetCollection(roomID)
		if !ok {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		// Check if user already exists as a member
		if _, ok = thisRoomCollection.Document(roomUsersKey).Get(userID); ok {
			w.WriteHeader(http.StatusConflict)
			return
		}

		// Verify that they were invited
		invIface, ok := thisRoomCollection.Document(roomInvitesKey).Get(userID)
		if !ok {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		inv, ok := invIface.(RoomInvite)
		if !ok {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		// Make sure the invite isn't expired
		expTime, err := time.Parse(time.RFC3339, inv.ExpiresAt)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		if !time.Now().Before(expTime) {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		// Update the user list to include newbie
		thisRoomCollection.Document(roomUsersKey).Set(userID, userID)

		// Send welcome message
		message := NewMessage(fmt.Sprintf("%s has joined the room. Say hi!", userID), Identity{"system", "system"})
		thisRoomCollection.Document(roomMessagesKey).Set(message.ID, message)

		w.WriteHeader(http.StatusOK)
	}
}

func InviteRoomHandler(roomsCollection *memcache.Collection) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		roomID := chi.URLParam(r, "roomID")
		if roomID == "" {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		// Get the authed user generated by the ApiAuthMiddleware
		userID, ok := r.Context().Value("userID").(string)
		if !ok {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		b, err := ioutil.ReadAll(r.Body)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		var iub InviteUserBody
		if err = json.Unmarshal(b, &iub); err != nil {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		thisRoomCollection, ok := roomsCollection.GetCollection(roomID)
		if !ok {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		// Only owners can invite for now. TODO expand the permissions on this.
		owner, _ := thisRoomCollection.Document(roomMetadataKey).Get("OwnerID")
		ownerID, ok := owner.(string)
		if !ok || ownerID != userID {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		// Add invite to invite list. TODO make duration customizable?
		inv := NewRoomInvite(iub.ID, userID, time.Hour*168)
		thisRoomCollection.Document(roomInvitesKey).Set(iub.ID, inv)

		w.WriteHeader(http.StatusOK)
	}
}

func ListMessagesHandler(roomsCollection *memcache.Collection) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		roomID := chi.URLParam(r, "roomID")
		if roomID == "" {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		userID, ok := r.Context().Value("userID").(string)
		if !ok {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		thisRoomCollection, ok := roomsCollection.GetCollection(roomID)
		if !ok {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		if _, ok = thisRoomCollection.Document(roomUsersKey).Get(userID); !ok {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		//response := struct {
		//	Messages []*Message `json:"messages"`
		//}{}

		// TODO this is probably wrong as a mother trucker as well
		var messages []Message
		messageIfaces := thisRoomCollection.Document(roomMessagesKey).Values()
		for _, messageIface := range messageIfaces {
			message, ok := messageIface.(Message)
			if ok {
				messages = append(messages, message)
			}
		}

		b, err := json.Marshal(messages)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
		w.Write(b)
	}
}

func SendMessageHandler(roomsCollection *memcache.Collection) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		roomID := chi.URLParam(r, "roomID")
		if roomID == "" {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		userID, ok := r.Context().Value("userID").(string)
		if !ok {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		b, err := ioutil.ReadAll(r.Body)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		var smb SendMessageBody
		if err = json.Unmarshal(b, &smb); err != nil {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		thisRoomCollection, ok := roomsCollection.GetCollection(roomID)
		if !ok {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		displayNameIface, ok := thisRoomCollection.Document(roomUsersKey).Get(userID)
		if !ok {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		displayName, ok := displayNameIface.(string)
		if !ok {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		// Send the new message
		message := NewMessage(smb.Message, Identity{displayName, userID})
		thisRoomCollection.Document(roomMessagesKey).Set(message.ID, message)

		b, err = json.Marshal(message)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
		w.Write(b)
	}
}

//
//func PatchRoomUserHandler(rm *RoomManager) func(w http.ResponseWriter, r *http.Request) {
//	return func(w http.ResponseWriter, r *http.Request) {
//		id := chi.URLParam(r, "ID")
//		if id == "" {
//			w.WriteHeader(http.StatusBadRequest)
//			return
//		}
//
//		targetUserID := chi.URLParam(r, "userID")
//		if id == "" {
//			w.WriteHeader(http.StatusBadRequest)
//			return
//		}
//
//		b, err := ioutil.ReadAll(r.Body)
//		if err != nil {
//			w.WriteHeader(http.StatusBadRequest)
//			return
//		}
//
//		var requestBody PatchRoomUserBody
//		err = json.Unmarshal(b, &requestBody)
//		if err != nil {
//			w.WriteHeader(http.StatusBadRequest)
//			return
//		}
//
//		// TODO do some permission checking against an API key
//		room, err := rm.GetRoom(id)
//		if err != nil {
//			w.WriteHeader(http.StatusBadRequest) // TODO maybe should be more useful here (not found vs unauthorized etc)
//			return
//		}
//
//		v := r.Context().Value("userID")
//		userID, ok := v.(string)
//		if !ok {
//			w.WriteHeader(http.StatusInternalServerError)
//			return
//		}
//
//		// Shortcut for targeting yourself
//		if targetUserID == "@me" {
//			targetUserID = userID
//		}
//
//		// TODO eventually we should do some ACL checks here. But for now you can only change your own name.
//		if userID != targetUserID {
//			w.WriteHeader(http.StatusUnauthorized)
//			return
//		}
//
//		err = room.UpdateUserName(targetUserID, requestBody.DisplayName)
//		if err != nil {
//			w.WriteHeader(http.StatusBadRequest) // TODO really really should have better error reporting/logging
//			return
//		}
//
//		w.WriteHeader(http.StatusOK)
//	}
//}
